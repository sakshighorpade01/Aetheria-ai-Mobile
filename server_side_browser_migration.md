# Server-Side Browser Migration Guide

This document outlines the technical plan to migrate the Aetheria AI browser automation from a client-side proxy architecture (Electron/Socket.IO) to a robust server-side headless implementation suitable for mobile PWA support.

## 1. Architecture Shift

### Current (Deprecated for Mobile)
-   **Flow:** Agent -> `BrowserTools` (Proxy) -> Redis/Socket.IO -> Client Frontend -> User's Browser (Electron Webview).
-   **Limitation:** Mobile browsers (Safari/Chrome on iOS/Android) do not support the level of control required (e.g., programmatic clicking, typing, full-page screenshots) via simple JavaScript injection from a server, and background execution is limited.

### New (Server-Side)
-   **Flow:** Agent -> `ServerBrowserTools` -> Playwright (Python) -> Headless Chromium (Running on Server).
-   **Benefit:** Consistent behavior across all client devices (Mobile, Desktop, Web). The "browser" lives on the server, so the user's device capabilities don't matter.

## 2. Technology Stack
We will use **Playwright for Python** (Async API). It is modern, fast, reliable, and handles dynamic content (SPAs) better than Selenium.

**Dependencies to Add:**
-   `playwright`
-   `nest_asyncio` (Optional, may be needed if running inside existing event loops)

## 3. Implementation Steps

### Step 1: Update Dependencies
Add the following to `python-backend/requirements.txt`:
```text
playwright==1.40.0
```
*Note: You will also need to install the browsers in your Dockerfile or deployment script: `playwright install chromium`.*

### Step 2: Create `server_browser_tools.py`
Replace the existing `browser_tools.py` or create a new file. This class will no longer inherit from `Toolkit` in the same way (depending on Agno version) but will implement the same tool methods.

#### Key Components:

1.  **Initialization (`__init__`)**:
    -   Start the Playwright instance.
    -   Launch a browser (Chromium).
    -   Create a **Browser Context** (isolated session with cookies/storage).
    -   Create a **Page** (tab).

2.  **State Management**:
    -   Keep track of the `playwright`, `browser`, `context`, and active `page` objects as instance variables.
    -   Since the Agent is persistent per session, you might want to keep the browser alive for the duration of the session, or launch/close it per task (slower but stateless). *Recommendation: Keep alive per session if possible, or use a persistent context.*

3.  **Method Mapping (Porting Logic):**

| Tool Method | Playwright Equivalent | Implementation Notes |
| :--- | :--- | :--- |
| `navigate(url)` | `await page.goto(url)` | Handle timeouts and `wait_until='domcontentloaded'`. |
| `click(selector)` | `await page.click(selector)` | **Change:** Use CSS selectors instead of numeric `element_id`. Playwright uses selectors natively. |
| `type_text(selector, text)` | `await page.fill(selector, text)` | |
| `scroll(direction)` | `await page.evaluate(...)` | Execute JS to scroll `window.scrollBy`. |
| `get_current_view()` | `await page.screenshot()` | Return base64 image or upload to Supabase and return URL. Also run `await page.content()` to get HTML/Text. |
| `go_back()` | `await page.go_back()` | |
| `extract_text` | `await page.inner_text('body')` | Or specific selectors. |

### Step 3: Handling "Interactive Elements"
The old system used numeric IDs (`element_id`) generated by a custom JS script on the client.
**New Approach:**
-   The Agent should write **CSS Selectors** directly (e.g., `"button[name='submit']"`, `"#search-bar"`).
-   **Prompt Engineering:** Update the System Prompt to tell the AI: "You are controlling a browser. Use CSS selectors to interact with elements. View the HTML structure to find selectors."
-   **Helper:** You can still inject a script to highlight elements or generate a "accessibility tree" text representation to help the AI "see" the page structure if raw HTML is too messy.

### Step 4: Screenshot Handling
Since the user can't "see" the server's browser, `get_current_view` becomes critical.
1.  **Capture:** `screenshot_bytes = await page.screenshot(full_page=False)`
2.  **Storage:** Upload `screenshot_bytes` to Supabase Storage (bucket: `media-uploads`).
3.  **Return:** Return the public URL of the uploaded image so the Agent (and the user's chat UI) can display it.

### Step 5: Cleanup
Ensure `browser.close()` is called when the session ends or the agent finishes its run to prevent memory leaks on the server.

## 4. Code Skeleton (Example)

```python
from agno.tools import Toolkit
from playwright.async_api import async_playwright
import base64

class ServerBrowserTools(Toolkit):
    def __init__(self):
        super().__init__(name="server_browser")
        self.playwright = None
        self.browser = None
        self.page = None
        # Register tools...
        self.register(self.navigate)
        self.register(self.click)
        # ...

    async def start_browser(self):
        if not self.playwright:
            self.playwright = await async_playwright().start()
            self.browser = await self.playwright.chromium.launch(headless=True)
            self.page = await self.browser.new_page()

    async def navigate(self, url: str):
        await self.start_browser()
        await self.page.goto(url)
        return {"status": "success", "url": self.page.url}

    async def get_view(self):
        await self.start_browser()
        screenshot = await self.page.screenshot()
        # Upload to Supabase logic here...
        return {"status": "success", "screenshot_url": "..."}
```

## 5. Modifications to `assistant.py`
1.  **Import:** Change `from browser_tools import BrowserTools` to `from server_browser_tools import ServerBrowserTools`.
2.  **Initialization:** Remove `socketio`, `sid`, and `redis_client` from the constructor arguments. The server-side browser doesn't need to talk to the client socket.
3.  **System Prompt:** Update the "BrowserTools" section to remove references to "client connection" and "element IDs". Emphasize "CSS Selectors" and "Server-side execution".

## 6. Removing Redundancy
Once implemented:
-   Delete `js/socket-service.js` browser listeners.
-   Delete `python-backend/browser_tools.py` (the old proxy).
-   Clean up `sockets.py` event handlers.
